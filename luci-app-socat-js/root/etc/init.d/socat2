#!/bin/sh /etc/rc.common
# OpenWrt socat

USE_PROCD=1
START=99

CONFIG=socat
CONFIG_PATH="/var/etc/$CONFIG"
BIN="/usr/bin/socat"
NFTABLES=false

load_config_values() {
	local section="$1"

	config_get enable "$section" enable
	[ "$enable" = "0" ] && return 1

	config_get remarks "$section" remarks
	config_get protocol "$section" protocol
	config_get family "$section" family
	config_get proto "$section" proto
	config_get listen_port "$section" listen_port
	config_get reuseaddr "$section" reuseaddr
	config_get dest_proto "$section" dest_proto
	config_get dest_ip "$section" dest_ip
	config_get dest_port "$section" dest_port
	config_get firewall_accept "$section" firewall_accept
	config_get proxy "$section" proxy
	config_get proxy_server "$section" proxy_server
	config_get proxy_port "$section" proxy_port

	return 0
}

build_socat_command() {
	local section="$1"
	load_config_values "$section" || return 1

	[ "$reuseaddr" = "1" ] && reusearg=",reuseaddr" || reusearg=""

	case "$family" in
		4)
			listen_proto="${proto}4"
			ipv6arg=""
			;;
		6)
			listen_proto="${proto}6"
			ipv6arg=",ipv6-v6only"
			;;
		4/6)
			listen_proto="${proto}6"
			ipv6arg=""
			;;
		*)
			echo "[$section] Invalid family value: '$family'" >&2
			return 1
			;;
	esac

	# Proxy settings
	local proxy_dest=""
	local proxy_arg=""
	if [ -n "$proxy" ]; then
		case "$proxy" in
			socks4/4a)
				dest_proto="socks4a"
				proxy_arg="socksport"
				;;
			http)
				dest_proto="proxy"
				proxy_arg="proxyport"
				;;
		esac
		[ -n "$proxy_server" ] && dest_proto="${dest_proto}:${proxy_server}"
		[ -n "$proxy_port" ] && proxy_dest=",${proxy_arg}=${proxy_port}"
	fi

	# socat args as array (procd-friendly)
	local listen_arg="${listen_proto}-listen:${listen_port}${ipv6arg}${reusearg},fork"
	local dest_arg="${dest_proto}:${dest_ip}:${dest_port}${proxy_dest}"

	SOCAT_CMD_ARGS="$listen_arg $dest_arg"
	return 0
}

start_instance() {
	local section="$1"
	build_socat_command "$section" || return 0
	add_firewall_rule "$section"
	
	set -- $SOCAT_CMD_ARGS

	procd_open_instance "$section"
	procd_set_param command "$BIN" "$@"
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_close_instance
}

add_firewall_rule() {
	local section="$1"
	load_config_values "$section"

	[ "$firewall_accept" != "1" ] && return 0

	local ipv4=false
	local ipv6=false
	case "$family" in
		4) ipv4=true ;;
		6) ipv6=true ;;
		4/6) ipv4=true; ipv6=true ;;
		*) echo "Invalid firewall family in [$section]" >&2; return 1 ;;
	esac

	if $NFTABLES; then
		$ipv4 && echo "	meta nfproto ipv4 $proto dport $listen_port accept" >> /var/etc/$CONFIG.include.nft
		$ipv6 && echo "	meta nfproto ipv6 $proto dport $listen_port accept" >> /var/etc/$CONFIG.include.nft
	else
		$ipv4 && iptables -A SOCAT -p $proto --dport $listen_port -m comment --comment "$remarks" -j ACCEPT
		$ipv6 && ip6tables -A SOCAT -p $proto --dport $listen_port -m comment --comment "$remarks" -j ACCEPT
	fi
}

add_rule() {
	if $NFTABLES; then
		cat <<-EOF > /var/etc/$CONFIG.include.nft
			flush chain inet fw4 socat_input
			table inet fw4 {
				chain socat_input {
		EOF
	else
		iptables -N SOCAT 2>/dev/null
		iptables -I INPUT -j SOCAT 2>/dev/null
		ip6tables -N SOCAT 2>/dev/null
		ip6tables -I INPUT -j SOCAT 2>/dev/null
	fi
}

gen_include() {
	echo '#!/bin/sh' > /var/etc/$CONFIG.include
	if $NFTABLES; then
		cat <<-EOF >> /var/etc/$CONFIG.include.nft
				}
			}
		EOF
		echo "nft -f /var/etc/$CONFIG.include.nft" >> /var/etc/$CONFIG.include
		( . /var/etc/$CONFIG.include )
	else
		cat <<-EOF >> /var/etc/$CONFIG.include
			iptables-save -c | grep -v "SOCAT" | iptables-restore -c
			iptables-restore -n <<-EOT
			$(iptables-save -t filter | grep "SOCAT" | sed 's/^-A \(INPUT\)/-I \1 1/')
			COMMIT
			EOT

			ip6tables-save -c | grep -v "SOCAT" | ip6tables-restore -c
			ip6tables-restore -n <<-EOT
			$(ip6tables-save -t filter | grep "SOCAT" | sed 's/^-A \(INPUT\)/-I \1 1/')
			COMMIT
			EOT
		EOF
	fi
}

del_rule() {
	$NFTABLES && nft flush chain inet fw4 socat_input
	iptables -D INPUT -j SOCAT 2>/dev/null
	iptables -F SOCAT 2>/dev/null
	iptables -X SOCAT 2>/dev/null
	ip6tables -D INPUT -j SOCAT 2>/dev/null
	ip6tables -F SOCAT 2>/dev/null
	ip6tables -X SOCAT 2>/dev/null
}

start_service() {
	local enable
	enable=$(uci -q get "$CONFIG.@global[0].enable")
	[ "$enable" = "0" ] && {
		stop_service
		return
	}

	[ -x /sbin/fw4 ] && NFTABLES=true
	mkdir -p "$CONFIG_PATH"

	add_rule
	config_load "$CONFIG"
	config_foreach start_instance "config"
	gen_include
}

stop_service() {
	[ -x /sbin/fw4 ] && NFTABLES=true
	rm -f /var/etc/$CONFIG.include /var/etc/$CONFIG.include.nft
	sleep 1
	killall -9 socat >/dev/null 2>&1
	del_rule
	rm -rf "$CONFIG_PATH"
}

service_triggers() {
	procd_add_reload_trigger "$CONFIG"
}

